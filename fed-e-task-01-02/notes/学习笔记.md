## 1、为什么学习函数式编程范式

### 1.1、为什么学习函数式编程

![image-20200524203445192](../../images/image-20200524203445192.png)



### 1.2、什么是函数式编程

![image-20200524203725153](../../images/image-20200524203725153.png)

```javascript
// 非函数式
let num1 = 2
let num2 = 3
let sum = num1 + num2
console.log(sum)

// 函数式
function add(n1, n2) {
    return n1 + n2
}
console.log(add(2, 3))
```



### 1.3、函数式一等公民

1. 函数可以作为参数传递
2. 函数可以作为返回值
3. 函数可以存储在变量中



### 1.4、高阶函数

- 可以把函数作为参数传递给另一个函数
- 可以把函数作为另一个函数的返回结果

```javascript
// 函数作为参数
function forEach(array, fn) {
    for(let i = 0;i < array.length;i++) {
        fn(array[i])
    }
}
let arr = [1,3, 4, 7, 8]
forEach(arr, function(item) {
    console.log(item)
})

// ---------------------------------------------------

function filter(array, fn) {
    let results = []
    for(let i = 0;i < array.length;i++) {
        if(fn(array[i])) {
            results.push(array[i])
        }
    }
    return results
}
let arr1 = [1, 3, 4, 7, 8]
let r = filter(arr1, function(item) {
    return item % 2 === 0
})
console.log(r)

// 函数作为返回值
function makeFn() {
    let msg = 'hello function'
    return function() {
        console.log(msg)
    }
}
const fn = makeFn()
fn()
makeFn()()

// ---------------------------------------------------

function once(fn) {
    let done = false
    return function() {
        if(!done) {
            done = true
            return fn.apply(this, arguments)
        }
    }
}
let pay = once(function(money) {
    console.log('pay:', money)
})
pay(5)
pay(5)
pay(5)
pay(5)
```



### 1.5、常用的高阶函数

- forEach
- map
- filter
- every
- some
- find/findIndex
- reduce
- sort
- ......

```
//map
const map = function(array, fn) {
    let results = []
    for(let value of array) {
        results.push(fn(value))
    }
    return results
}
let arr = [1, 2, 3, 4]
console.log(map(arr, v => v * v))

// every
const every = function(array, fn) {
    let result = true
    for(let value of array) {
        result = fn(value)
        if(!result) {
            break
        }
    }
    return result
}
console.log(every([9, 12, 14], v => v > 10))

// some
const some = (array, fn) => {
    let result = false
    for(let value of array) {
        if(fn(value)) {
            result = true
            break
        }
    }
    return result
}
console.log(some([1, 3, 6, 9], v => v % 2 === 0))
```



### 1.6、闭包

定义：函数和其周围的状态（词法环境）的引用捆绑在一起形成闭包

闭包可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员

```javascript
// 闭包举例
function makeFn() {
    let msg = 'hello function'
    return function() {
        console.log(msg)
    }
}
const fn = makeFn()
fn()
```

**闭包的本质：** 函数在执行的时候会放到一个执行栈上，当函数执行完毕之后会从执行栈上一处，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员。

```javascript
// 案例
function makePower(power) {
    return function(number) {
        return Math.pow(number, power)
    }
}
let power2 = makePower(2)
let power3 = makePower(3)
console.log(power2(4))
console.log(power3(4))
```



### 1.7、纯函数和lodash

![image-20200524222647181](../../images/image-20200524222647181.png)

```
// 案例
// 纯函数
let array = [1, 2, 3, 4, 5]
console.log(array.slice(0, 3))  // [1, 2, 3]
console.log(array.slice(0, 3))  // [1, 2, 3]
console.log(array.slice(0, 3))  // [1, 2, 3]

// 不纯函数
console.log(array.splice(0, 3))  // [1, 2, 3]
console.log(array.splice(0, 3))  // [4, 5]
console.log(array.splice(0, 3))  // []
```

